# WebSocket и gRPC в StressPulse

Добавил поддержку WebSocket и gRPC тестирования в StressPulse. Оказалось, что это очень нужная штука - половина современных приложений сидит на этих протоколах, а нормальных инструментов для нагрузочного тестирования не хватало.

## WebSocket тестирование

Честно говоря, долго откладывал эту фичу, но когда пришлось тестировать чат-сервер на работе, понял что без этого никуда. Обычные HTTP тесты не передают специфику постоянных соединений.

### Что умеет

- Создавать кучу WebSocket соединений одновременно (только не переборщи)
- Автоматически обмениваться сообщениями
- Те же паттерны нагрузки что и для HTTP
- Показывать сколько соединений живых, сколько упало
- Считать пропускную способность сообщений

### Как запустить

Простейший пример:
```bash
# Подключаемся к публичному echo серверу
go run main.go -websocket -websocket-url "ws://echo.websocket.org"
```

Это создаст 5 соединений в секунду (по умолчанию) и будет каждую секунду отправлять сообщения размером 256 байт.

Более реальный пример:
```bash
# Тестируем свой чат-сервер
go run main.go -websocket -websocket-url "ws://localhost:8080/chat" \
  -websocket-cps 15 \
  -websocket-message-interval 3s \
  -websocket-message-size 128 \
  -websocket-headers "Authorization:Bearer your-token"
```

### Паттерны нагрузки

Тут всё как с HTTP, но есть нюансы:

- **constant** - постоянно создаёт новые соединения. Осторожно, может быстро набрать кучу открытых сокетов
- **spike** - резкие всплески соединений. Хорошо проверяет как сервер справляется с наплывом
- **cycle** - циклами меняет нагрузку. Полезно для имитации суточных пиков
- **ramp** - постепенно увеличивает. Я обычно с этого начинаю
- **random** - хаотично меняется. Ближе всего к реальности

Пример со спайками:
```bash
go run main.go -websocket -websocket-url "ws://localhost:8080/game" \
  -websocket-cps 20 \
  -websocket-pattern spike \
  -websocket-message-interval 500ms \
  -duration 10m
```

### Настройки которые важны

- `-websocket-cps` - connections per second, сколько новых соединений в секунду создавать
- `-websocket-message-interval` - как часто отправлять сообщения (не делай слишком часто)
- `-websocket-message-size` - размер сообщений в байтах
- `-websocket-headers` - заголовки для подключения (для авторизации например)

### Что смотреть в метриках

- `websocket_active_connections` - сколько соединений живых сейчас
- `websocket_connections_failed_total` - сколько не смогли подключиться
- `websocket_messages_sent_total` vs `websocket_messages_received_total` - видно потери
- `websocket_connection_time_seconds` - время установки соединения

Если connection_time растет или много failed_connections - значит сервер не справляется.

## gRPC тестирование

Это была более сложная задача. gRPC протокол не такой простой как WebSocket, плюс есть разные типы вызовов. Но в итоге получилось неплохо.

### Что поддерживает

- Health Check запросы (это такой стандарт в gRPC мире)
- Unary вызовы (обычные запрос-ответ)
- Streaming методы (пока базово, но работает)
- TLS соединения
- Метаданные (заголовки в gRPC терминологии)

### Простые примеры

Health check любого gRPC сервера:
```bash
go run main.go -grpc -grpc-addr "localhost:9000"
```

С нагрузкой:
```bash
go run main.go -grpc -grpc-addr "user-service:9000" -grpc-rps 50
```

Защищенное соединение:
```bash
go run main.go -grpc -grpc-addr "api.company.com:443" -grpc-secure \
  -grpc-service "UserService" \
  -grpc-metadata "authorization:Bearer xyz,tenant:prod"
```

### Типы методов

- **health_check** - стандартные проверки здоровья (по умолчанию)
- **unary** - обычные запросы, как HTTP
- **server_stream** - сервер шлет поток данных
- **client_stream** - клиент шлет поток
- **bidi_stream** - двусторонний поток

Честно говоря, streaming методы пока сделаны базово - они используют Watch из health service. Но для нагрузочного тестирования обычно хватает.

### Практические советы

1. **Начинай с низких RPS** - gRPC соединения тяжелее HTTP
2. **Используй connection pool** - он включен по умолчанию (5 соединений)
3. **TLS добавляет накладные расходы** - учитывай при тестировании
4. **Метаданные работают как HTTP заголовки** - туда можно передать авторизацию

### Отладка

Если что-то не работает, включай debug логи:
```bash
go run main.go -grpc -grpc-addr "localhost:9000" -log-level debug
```

Частые проблемы:
- Connection refused - проверь адрес и порт
- TLS handshake failed - либо сертификат кривой, либо порт не тот
- Context deadline exceeded - уменьши RPS или увеличь timeout

## Комбинированное тестирование

Самое интересное начинается когда комбинируешь разные типы нагрузки.

### Типичный микросервис

```bash
go run main.go \
  -http -http-url "http://user-service/api/users" -http-rps 100 \
  -grpc -grpc-addr "user-service:9000" -grpc-rps 50 \
  -cpu 30 \
  -memory -memory-target 200 \
  -metrics \
  -duration 15m
```

Тут проверяем и REST API и gRPC API одновременно, плюс даём фоновую нагрузку на ресурсы.

### SPA приложение

```bash
go run main.go \
  -http -http-url "https://app.company.com/api" -http-rps 200 \
  -websocket -websocket-url "wss://app.company.com/ws" -websocket-cps 30 \
  -websocket-message-interval 2s \
  -duration 30m
```

Имитируем пользователей которые ходят по API и сидят в чате/получают уведомления.

### Игровой сервер

```bash
go run main.go \
  -websocket -websocket-url "ws://game-server.com/game" \
  -websocket-cps 50 \
  -websocket-pattern spike \
  -websocket-message-interval 200ms \
  -websocket-message-size 64 \
  -duration 1h
```

Симулируем игроков которые постоянно шлют команды. Спайки имитируют моменты когда все одновременно что-то делают.

## Мониторинг

С метриками всё стандартно - запускаешь с `-metrics` и смотришь в Grafana. Полный стек мониторинга поднимается так:

```bash
docker-compose up -d
```

Grafana будет на http://localhost:3000 (admin/admin).

### На что смотреть

**WebSocket:**
- Соотношение успешных к неудачным соединениям
- Время установки соединения - если растет, сервер тормозит
- Пропускная способность сообщений

**gRPC:**
- Распределение статус кодов - что возвращает сервер
- Response time percentiles - 95th и 99th особенно важны
- Соотношение RPS к latency

## Практические кейсы

### Когда использовать WebSocket тестирование

- **Чат-серверы** - проверить сколько одновременных пользователей выдержит
- **Real-time приложения** - трейдинговые платформы, мониторинги
- **Игровые серверы** - особенно важно тестировать spike нагрузки
- **Push уведомления** - проверить как сервер справляется с множественными подписками

### Когда gRPC пригодится

- **Микросервисная архитектура** - тестировать межсервисное взаимодействие
- **Health checks** - проверить что все сервисы живы под нагрузкой
- **Streaming API** - тестировать производительность потоковых данных
- **High-performance API** - gRPC быстрее HTTP для многих сценариев

## Известные ограничения

### WebSocket

- Может быстро набрать много открытых сокетов - следи за лимитами ОС
- На Windows иногда проблемы с SSL соединениями
- При очень высоких CPS может тормозить - пока не оптимизировал до конца

### gRPC

- Streaming методы реализованы базово
- TLS может быть капризным на разных версиях Go
- Connection pool фиксированного размера (5 соединений)

## Best Practices из опыта

1. **Начинай с малого** - сначала 1-5 соединений, потом увеличивай
2. **Мониторь целевой сервер** - StressPulse может грузить, но сервер может не справляться
3. **Используй паттерны** - реальная нагрузка никогда не бывает постоянной
4. **Сохраняй результаты** - включай метрики и записывай что получается
5. **Тестируй граничные случаи** - spike паттерн особенно хорошо находит проблемы